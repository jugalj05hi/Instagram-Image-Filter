# Assignment 7

Group Member #1: Jugal Joshi
Group Member #2: Urvaksh Padamsi


This document explains how to use the varios models with the scope of Assigment 7.

THe submitted files contains 4 main interfaces, which have varios implementains that can be called depending ont he requirements.

Interfaces 
1) GenerateImage.java

	Methods:
	a) getImage(): returns an image in the Buffrent image format after it has been generated.

	Implementaitons:
	a) Rainbow.java: Generates a rainbow image with horizontal stripes. 
	This class takes width and height as the initializing parameters, 
	after which the getImage method should be called to obtain the generated image.

	b) RainbowVertical.java: Generates a rainbow image with vertical stripes. 
	This class takes width and height as the initializing parameters, 
	after which the getImage method should be called to obtain the generated image.

	c) FlagOfFrance.java: Generates a the flag France of image with horizontal stripes. 
	This class takes width and height as the initializing parameters, 
	after which the getImage method should be called to obtain the generated image.

	d) FlagOfGreece.java: Generates a the flag Greece of image. 
	This class takes width and height as the initializing parameters, 
	after which the getImage method should be called to obtain the generated image.

	e) FlagOfGreece.java: Generates a the flag Greece of image. 
	This class takes width and height as the initializing parameters, 
	after which the getImage method should be called to obtain the generated image.
	
	f) CheckerBoard.java: Generates a Chekerboard image. 
	This class takes one side of a square within the board as the initializing parameter, 
	after which the getImage method should be called to obtain the generated image.
	
	g) FlagOfSwitzerland.java: Generates a Flag OfSwitzerland image. 
	This class takes one side of a square within the board as the initializing parameter, 
	after which the getImage method should be called to obtain the generated image.

2) Filter.java

	Methods:
	a)blur: returns the blurred image in BufferedImageFormat.

	b)sharpen: returns the sharpened image in BufferedImageFormat.

	c)greyscale: returns the greyscale image in BufferedImageFormat.

	d)sepia: returns the sepia image in BufferedImageFormat.

	e)dither: returns the dithered image in BufferedImageFormat.

	f)mosaic: returns the mosaic image in BufferedImageFormat.

	Implementaions:
	a)FilerImpl.java: this expects a bufferedimage as the imput, after which the varios interfacemethods can be used.

3)ImageReader

	Methods:
	a)getImage: returns the readImage.

	Implementaions:
	a)ImageReaderImpl.java: takes a file path as the input, after whicht the image can be retieved.

4)ImageWiter

	Methods:
	a)writeImage: writes the image
		paramentes:
		i)image: the image to be written
		ii)writePath: where the image is to be written
		iii)imageSaveType: the format the image must be saved in.

	Implementaions:
	a)ImageReaderImpl.java: takes a file path as the input, after whicht the image can be retieved.
5) Command
	
	Methods:
	a) execute: executes the command list



Other than than these classes and interface there are 3 additional files
1) SupportedImageFormats.java (enum): tho store the suppoorted file formats
2) Main.java: the driver for this model.
3) Controller.java: Controller of the program.
4) ModelTests.java: a testing class for some basic tests.





Citations:
one image of New york city has been obtained from the following link
https://unsplash.com/photos/wh-7GeXxItI
unsplash provies fair use pictures that anyone can access

one image of Boston Fenway park has been obtained from the following link
https://unsplash.com/photos/jbxJmsJR4QQ
unsplash provies fair use pictures that anyone can access

rest of the images provided are either images that pefromed operations on this image or were generated by the code.
we authoriz the use of these imaages withing the scope of this assigment and anyfuture assigment that depends on this one.


Additions:

	Added 2 abstract classes in the createimages package named:
	1) AbstractSquares: to generate a sqare pattern, used this to astract certain common functions of the Swiss flag and checkerboard.
	2) AbstarctStripes: to abstract certain functions of all the flags and rainbow images.
	3) Controller: Added a new controller class to implment mvc design pattern.
	4) Command: A new command class that has method execute(), whichever class implements this class, can execute the set
	of commands needed with the execute method.
	5) CommandController: This class takes in argument of the type Command and  also has an excute() method that calls the 
	argument's execute().
	6.) CheckerboardGenerateCommand: This class contains the commands to generate a checkerboard.
	7.) FranceFlagGenerateCommand: This class contains the commands to generate the flag of France.
	8.) GenerateImageCommand: This class contains the commands to generate the different types of flags/ images.
	9.) GreeceFlagGenerateCommand: This class contains the commands to generate the flag of Greece.
	10.) RainbowGenerateCommand: This class contains the commands to generate the rainbow flag in both the orientation.
	11.) SaveImageCommand: This class contains the commands to save the image with effects by calling a list of commands with
	WriteImage class' execute() method.
	12.) SwitzerlandFlagGenerate: This class contains the commands to generate the flag of Switzerland.
	13.) WriteImageCommand: This class contains the commands to write the image to the file system.

these 2 classes were simply used for abstracting, code was simply moved to these classes without any changes from the rainbow or checkerboard class.

Modifications:
1) added 2 methods to the Filter interface to accomodate dithering and mosaicing.
2) implemented the 2 methods in FilterImpl
3) added method clamp() to clamp rgb values between the range 0-255.

How to run the program:

	1.) Create a file called input.txt and load the commands in it, the command syntax goes this way:

		a)load -> Will prompt user to load the file by asking them to provide the file loaction.

		b)generate <Flag/pattern> -> the command generate followed by the name of the flag or pattern will generate the flag/pattern. Eg: generate France flag

		c)<name of the filter> -> By simply entering the name of the filter will apply the filter as many times as the user writes it until the save command is entered by the user. Eg: sepia, blur, dither and etc.
		
		d)save -> the save command will save the image with applied filter. The name of the file would be <NameOfFile> -<Filter>. <FileType>. For example if the user has applied blur, sepia, dither filter on the file name nyc.png, the generated file name would be nyc-blur-sepia-dither.png. 

		e)If the user wants the mosaic image, they'd be prompted to enter the number of seeds.
		The generation of Mosaic may take time depending upon the PC. So please be patient.

	2.) After creating the file, on the command line/ terminal run the jar file with the command "java -jar NameOfJar.jar input.txt "

	3.) Afterwich the user would be prompted to enter the location/ path of the image. 

	4.) Upon successfully execution of the program, the program would generate the image as mentioned in 1.d.



Controller Design:
The controller is designed with Command Pattern Design. The flow of the controller goes this way: 

1.) The controller reads the input file passed from the main's args[0],and based on the input from it acts accordingly. 

	a)load -> Will prompt user to load the file by asking them to provide the file loaction.

	
	generate <Flag/pattern> -> the command generate followed by the name of the flag or pattern will generate the flag/pattern by calling the respective command class i.e GreeceFlagGenerateCommand, FranceFlagGenerateCommand and etc and then executing with CommandController's execute() 

	<name of the filter> -> By simply entering the name of the filter will apply the filter as many times as the user writes it until the save command is entered by the user. 
	
	save -> the save command will save the image with applied filter. The name of the file would be <NameOfFile> -<Filter>. <FileType>. The SaveImage class' execute() method would be called which will do the job. 

2.) After determing the the type of command the control will act accordingly: 

	load -> It will load the image by extracting the String in args[0] of the program i.e the name of the file. And will call the ImageReaderImpl class to extract the image from the image path. The ImageReaderImpl is from the model.


	generate <Flag/pattern> -> The controller would call the respective GenerateCommand class to generate the images. For eg: when generating rainbow, it will make a new object of  RainbowGenerateCommand and then pass the object into commandController class and then commandController object will call execute() and then the image would be generated.
	
	filter -> The controller will apply the filter with the help of newly created Filter image. Eg: image=filter.greyscale()
	
	save -> the save command will save the image with applied filter. The name of the file would be <NameOfFile> -<Filter>. <FileType>. The SaveImage class' execute() method would be called which will do the job by calling WriteImage class' execute()


3) Justification for Controller Addition:

The main reason for adding many classes to generate pattern/ filter is to encapsulate the commands into objects and implement the Command Design Pattern. The interface Command has a method that is called to execute the commands of the class that implements the Command interface. The following class implements Command interface:
		CheckerboardGenerateCommand
		FranceFlagGenerateCommand
		GenerateImageCommand
		GreeceFlagGenerateCommand
		RainbowGenerateCommand
		SaveImageCommand
		SwitzerlandFlagGenerate
		WriteImageCommand
		
Whenever the execute of these classes is called, it will execute the commands to the do the necessary task assigned by a class, thus following the S of SOLID principle in the process. 

Now to bring the uniformity to table, we make another class called CommandController which will take Command objects as an argument and will execute the command object's excute() in CommandController's execute() method. 

This way we are decluttering the controller and reducing the coupling in the process. 


Some features that can be seen lacking will be taken care with the implementation of the view in the next assignment.

	

	




